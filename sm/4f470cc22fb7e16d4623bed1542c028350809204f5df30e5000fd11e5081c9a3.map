{"version":3,"sources":["jsdelivr-header.js","/npm/moo@0.5.2/moo.js"],"names":[],"mappings":"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","file":"/npm/moo@0.5.2/moo.js/+esm","sourceRoot":"","sourcesContent":["/**\n * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.\n * Original file: /npm/moo@0.5.2/moo.js\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\n","(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function pad(s, length) {\n    if (s.length > length) {\n      return s\n    }\n    return Array(length - s.length + 1).join(\" \") + s\n  }\n\n  function lastNLines(string, numLines) {\n    var position = string.length\n    var lineBreaks = 0;\n    while (true) {\n      var idx = string.lastIndexOf(\"\\n\", position - 1)\n      if (idx === -1) {\n        break;\n      } else {\n        lineBreaks++\n      }\n      position = idx\n      if (lineBreaks === numLines) {\n        break;\n      }\n      if (position === 0) {\n        break;\n      }\n    }\n    var startPosition = \n      lineBreaks < numLines ?\n      0 : \n      position + 1\n    return string.substring(startPosition).split(\"\\n\")\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: … ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n\n    // Use a JavaScript Map to map keywords to their corresponding token type\n    // unless Map is unsupported, then fall back to using an Object:\n    var isMap = typeof Map !== 'undefined'\n    var reverseMap = isMap ? new Map : Object.create(null)\n\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        if (isMap) {\n          reverseMap.set(keyword, tokenType)\n        } else {\n          reverseMap[keyword] = tokenType\n        }\n      })\n    }\n    return function(k) {\n      return isMap ? reverseMap.get(k) : reverseMap[k]\n    }\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedText = info ? info.queuedText: \"\";\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedText: this.queuedText,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      var err = new Error(this.formatError(token, \"invalid syntax\"))\n      throw err;\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    \n    var numLinesAround = 2\n    var firstDisplayedLine = Math.max(token.line - numLinesAround, 1)\n    var lastDisplayedLine = token.line + numLinesAround\n    var lastLineDigits = String(lastDisplayedLine).length\n    var displayedLines = lastNLines(\n        this.buffer, \n        (this.line - token.line) + numLinesAround + 1\n      )\n      .slice(0, 5)\n    var errorLines = []\n    errorLines.push(message + \" at line \" + token.line + \" col \" + token.col + \":\")\n    errorLines.push(\"\")\n    for (var i = 0; i < displayedLines.length; i++) {\n      var line = displayedLines[i]\n      var lineNo = firstDisplayedLine + i\n      errorLines.push(pad(String(lineNo), lastLineDigits) + \"  \" + line);\n      if (lineNo === token.line) {\n        errorLines.push(pad(\"\", lastLineDigits + token.col + 1) + \"^\")\n      }\n    }\n    return errorLines.join(\"\\n\")\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n"]}